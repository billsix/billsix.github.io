<!doctype html>
<html class="no-js" lang="en" data-content_root="./">
  <head><meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="Index" href="genindex.html"><link rel="search" title="Search" href="search.html"><link rel="next" title="Dealing with Files" href="files.html"><link rel="prev" title="Your First Programs" href="firstprog.html">

    <!-- Generated with Sphinx 8.1.3 and Furo 2025.09.25 -->
        <title>All About Functions - Programming From The Ground Up 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="static/pygments.css?v=acfd86a5" />
    <link rel="stylesheet" type="text/css" href="static/styles/furo.css?v=50c23ec3" />
    <link rel="stylesheet" type="text/css" href="static/styles/furo-extensions.css?v=8dab3a3b" />
    
    


<style>
  body {
    --color-code-background: #f2f2f2;
  --color-code-foreground: #1e1e1e;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle site navigation sidebar">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc" aria-label="Toggle table of contents sidebar">
<label class="overlay sidebar-overlay" for="__navigation"></label>
<label class="overlay toc-overlay" for="__toc"></label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <span class="icon"><svg><use href="#svg-menu"></use></svg></span>
      </label>
    </div>
    <div class="header-center">
      <a href="index.html"><div class="brand">Programming From The Ground Up 0.0.1 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="index.html">
  
  <span class="sidebar-brand-text">Programming From The Ground Up 0.0.1 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="memory.html">Computer Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="firstprog.html">Your First Programs</a></li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">All About Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="files.html">Dealing with Files</a></li>
<li class="toctree-l1"><a class="reference internal" href="robust.html">Developing Robust Programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="memoryint.html">Intermediate Memory Topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="linking.html">Sharing Functions with Code Libraries</a></li>
<li class="toctree-l1"><a class="reference internal" href="counting.html">Counting Like a Computer</a></li>
<li class="toctree-l1"><a class="reference internal" href="otherlang.html">High-Level Languages</a></li>
<li class="toctree-l1"><a class="reference internal" href="optimization.html">Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="wherenext.html">Moving On from Here</a></li>
<li class="toctree-l1"><a class="reference internal" href="records.html">Reading and Writing Simple Records</a></li>
<li class="toctree-l1"><a class="reference internal" href="gdpapp.html">Using the GDB Debugger</a></li>
<li class="toctree-l1"><a class="reference internal" href="asciiap.html">Table of ASCII Codes</a></li>
<li class="toctree-l1"><a class="reference internal" href="cch.html">The C Language</a></li>
<li class="toctree-l1"><a class="reference internal" href="ctranslationap.html">C Idioms in Assembly Language</a></li>
<li class="toctree-l1"><a class="reference internal" href="guiap.html">GUI Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="instructionsap.html">Common x86 Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="fdlap.html">GNU Free Documentation License</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="view-this-page">
  <a class="muted-link" href="sources/functions.rst.txt" title="View this page">
    <svg><use href="#svg-eye"></use></svg>
    <span class="visually-hidden">View this page</span>
  </a>
</div>
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <section id="all-about-functions">
<span id="functionschapter"></span><h1>All About Functions<a class="headerlink" href="#all-about-functions" title="Link to this heading">¶</a></h1>
<section id="dealing-with-complexity">
<h2>Dealing with Complexity<a class="headerlink" href="#dealing-with-complexity" title="Link to this heading">¶</a></h2>
<p>In <a class="reference internal" href="firstprog.html#firstprogs"><span class="std std-ref">Your First Programs</span></a>, the programs we wrote only consisted of one
section of code. However, if we wrote real programs like that, it would
be impossible to maintain them. It would be really difficult to get
multiple people working on the project, as any change in one part might
adversely affect another part that another developer is working on.</p>
<p>To assist programmers in working together in groups, it is necessary to
break programs apart into separate pieces, which communicate with each
other through well-defined interfaces. This way, each piece can be
developed and tested independently of the others, making it easier for
multiple programmers to work on the project.</p>
<p>Programmers use <em>functions</em> to break their programs into pieces which
can be independently developed and tested. Functions are units of code
that do a defined piece of work on specified types of data. For example,
in a word processor program, I may have a function called
<code class="docutils literal notranslate"><span class="pre">handle_typed_character</span></code> which is activated whenever a user types in a
key. The data the function uses would probably be the keypress itself
and the document the user currently has open. The function would then
modify the document according to the keypress it was told about.</p>
<p>The data items a function is given to process are called its
<em>parameters</em>. In the word processing example, the key which was pressed
and the document would be considered parameters to the
<code class="docutils literal notranslate"><span class="pre">handle_typed_characters</span></code> function. The parameter list and the
processing expectations of a function (what it is expected to do with
the parameters) are called the function’s interface. Much care goes into
designing function interfaces, because if they are called from many
places within a project, it is difficult to change them if necessary.</p>
<p>A typical program is composed of hundreds or thousands of functions,
each with a small, well-defined task to perform. However, ultimately
there are things that you cannot write functions for which must be
provided by the system. Those are called <em>primitive functions</em> (or just
<em>primitives</em>) - they are the basics which everything else is built off
of. For example, imagine a program that draws a graphical user
interface. There has to be a function to create the menus. That function
probably calls other functions to write text, to write icons, to paint
the background, calculate where the mouse pointer is, etc. However,
ultimately, they will reach a set of primitives provided by the
operating system to do basic line or point drawing. Programming can
either be viewed as breaking a large program down into smaller pieces
until you get to the primitive functions, or incrementally building
functions on top of primitives until you get the large picture in focus.
In assembly language, the primitives are usually the same thing as the
system calls, even though system calls aren’t true functions as we will
talk about in this chapter.</p>
</section>
<section id="how-functions-work">
<span id="howfunctionswork"></span><h2>How Functions Work<a class="headerlink" href="#how-functions-work" title="Link to this heading">¶</a></h2>
<p>Functions are composed of several different pieces:</p>
<dl class="simple">
<dt>function name</dt><dd><p>A function’s name is a symbol that represents the address where the
function’s code starts. In assembly language, the symbol is defined
by typing the function’s name as a label before the function’s code.
This is just like labels you have used for jumping.</p>
</dd>
<dt>function parameters</dt><dd><p>A function’s parameters are the data items that are explicitly given
to the function for processing. For example, in mathematics, there is
a sine function. If you were to ask a computer to find the sine of 2,
sine would be the function’s name, and 2 would be the parameter. Some
functions have many parameters, others have none. <a class="footnote-reference brackets" href="#id7" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p>
</dd>
<dt>local variables</dt><dd><p>Local variables are data storage that a function uses while
processing that is thrown away when it returns. It’s kind of like a
scratch pad of paper. Functions get a new piece of paper every time
they are activated, and they have to throw it away when they are
finished processing. Local variables of a function are not accessible
to any other function within a program.</p>
</dd>
<dt>static variables</dt><dd><p>Static variables are data storage that a function uses while
processing that is not thrown away afterwards, but is reused for
every time the function’s code is activated. This data is not
accessible to any other part of the program. Static variables are
generally not used unless absolutely necessary, as they can cause
problems later on.</p>
</dd>
<dt>global variables</dt><dd><p>Global variables are data storage that a function uses for processing
which are managed outside the function. For example, a simple text
editor may put the entire contents of the file it is working on in a
global variable so it doesn’t have to be passed to every function
that operates on it. <a class="footnote-reference brackets" href="#id8" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> Configuration values are also often stored
in global variables.</p>
</dd>
<dt>return address</dt><dd><p>The return address is an “invisible” parameter in that it isn’t
directly used during the function. The return address is a parameter
which tells the function where to resume executing after the function
is completed. This is needed because functions can be called to do
processing from many different parts of your program, and the
function needs to be able to get back to wherever it was called from.
In most programming languages, this parameter is passed automatically
when the function is called. In assembly language, the <code class="docutils literal notranslate"><span class="pre">call</span></code>
instruction handles passing the return address for you, and
<code class="docutils literal notranslate"><span class="pre">ret</span></code> handles using that address to return back to where you
called the function from.</p>
</dd>
<dt>return value</dt><dd><p>The return value is the main method of transferring data back to the
main program. Most programming languages only allow a single return
value for a function.</p>
</dd>
</dl>
<p>These pieces are present in most programming languages. How you specify
each piece is different in each one, however.</p>
<p>The way that the variables are stored and the parameters and return
values are transferred by the computer varies from language to language
as well. This variance is known as a language’s <em>calling convention</em>,
because it describes how functions expect to get and receive data when
they are called. <a class="footnote-reference brackets" href="#id9" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a></p>
<p>Assembly language can use any calling convention it wants to. You can
even make one up yourself. However, if you want to interoperate with
functions written in other languages, you have to obey their calling
conventions. We will use the calling convention of the C programming
language for our examples because it is the most widely used, and
because it is the standard for Linux platforms.</p>
</section>
<section id="assembly-language-functions-using-the-c-calling-convention">
<span id="callingwritingassemblyfunctions"></span><h2>Assembly-Language Functions using the C Calling Convention<a class="headerlink" href="#assembly-language-functions-using-the-c-calling-convention" title="Link to this heading">¶</a></h2>
<p>You cannot write assembly-language functions without understanding how
the computer’s <em>stack</em> works. Each computer program that runs uses a
region of memory called the stack to enable functions to work properly.
Think of a stack as a pile of papers on your desk which can be added to
indefinitely. You generally keep the things that you are working on
toward the top, and you take things off as you are finished working with
them.</p>
<p>Your computer has a stack, too. The computer’s stack lives at the very
top addresses of memory. You can push values onto the top of the stack
through an instruction called <code class="docutils literal notranslate"><span class="pre">pushl</span></code>, which pushes either a
register or memory value onto the top of the stack. Well, we say it’s
the top, but the “top” of the stack is actually the bottom of the
stack’s memory. Although this is confusing, the reason for it is that
when we think of a stack of anything - dishes, papers, etc. - we think
of adding and removing to the top of it. However, in memory the stack
starts at the top of memory and grows downward due to architectural
considerations. Therefore, when we refer to the “top of the stack”
remember it’s at the bottom of the stack’s memory. You can also pop
values off the top using an instruction called <code class="docutils literal notranslate"><span class="pre">popl</span></code>. This
removes the top value from the stack and places it into a register or
memory location of your choosing..</p>
<p>When we push a value onto the stack, the top of the stack moves to
accomodate the additional value. We can actually continually push values
onto the stack and it will keep growing further and further down in
memory until we hit our code or data. So how do we know where the
current “top” of the stack is? The stack register, %esp;,
always contains a pointer to the current top of the stack, wherever it
is.</p>
<p>Every time we push something onto the stack with <code class="docutils literal notranslate"><span class="pre">pushl</span></code>, %esp;
gets subtracted by 4 so that it points to the new top of the stack
(remember, each word is four bytes long, and the stack grows downward).
If we want to remove something from the stack, we simply use the
<code class="docutils literal notranslate"><span class="pre">popl</span></code> instruction, which adds 4 to %esp; and puts the previous
top value in whatever register you specified. <code class="docutils literal notranslate"><span class="pre">pushl</span></code> and <code class="docutils literal notranslate"><span class="pre">popl</span></code>
each take one operand - the register to push onto the stack for
<code class="docutils literal notranslate"><span class="pre">pushl</span></code>, or receive the data that is popped off the stack for
<code class="docutils literal notranslate"><span class="pre">popl</span></code>.</p>
<p>If we simply want to access the value on the top of the stack without
removing it, we can simply use the %esp; register in
indirect addressing mode. For example, the following code moves whatever
is at the top of the stack into %eax;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">movl</span> <span class="p">(</span><span class="o">%</span><span class="n">esp</span><span class="p">),</span> <span class="o">%</span><span class="n">eax</span>
</pre></div>
</div>
<p>If we were to just do this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">movl</span> <span class="o">%</span><span class="n">esp</span><span class="p">,</span> <span class="o">%</span><span class="n">eax</span>
</pre></div>
</div>
<p>then %eax; would just hold the pointer to the top of the stack
rather than the value at the top. Putting %esp; in parenthesis
causes the computer to go to indirect addressing mode, and therefore we
get the value pointed to by %esp;. If we want to access
the value right below the top of the stack, we can simply issue this
instruction:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">movl</span> <span class="mi">4</span><span class="p">(</span><span class="o">%</span><span class="n">esp</span><span class="p">),</span> <span class="o">%</span><span class="n">eax</span>
</pre></div>
</div>
<p>This instruction uses the base pointer addressing mode (see
<a class="reference internal" href="memory.html#dataaccessingmethods"><span class="std std-ref">Data Accessing Methods</span></a>) which simply adds 4 to
%esp; before looking up the value being pointed to.</p>
<p>In the C language calling convention, the stack is the key element for
implementing a function’s local variables, parameters, and return
address.</p>
<p>Before executing a function, a program pushes all of the parameters for
the function onto the stack in the reverse order that they are
documented. Then the program issues a <code class="docutils literal notranslate"><span class="pre">call</span></code> instruction
indicating which function it wishes to start. The <code class="docutils literal notranslate"><span class="pre">call</span></code> instruction
does two things. First it pushes the address of the next instruction,
which is the return address, onto the stack. Then it modifies the
instruction pointer (%eip;) to point to the start of the
function. So, at the time the function starts, the stack looks like this
(the “top” of the stack is at the bottom on this example):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Parameter</span> <span class="c1">#N</span>
<span class="o">...</span>
<span class="n">Parameter</span> <span class="mi">2</span>
<span class="n">Parameter</span> <span class="mi">1</span>
<span class="n">Return</span> <span class="n">Address</span> <span class="o">&lt;---</span> <span class="p">(</span><span class="o">%</span><span class="n">esp</span><span class="p">)</span>
</pre></div>
</div>
<p>Each of the parameters of the function have been pushed onto the stack,
and finally the return address is there. Now the function itself has
some work to do.</p>
<p>The first thing it does is save the current base pointer register,
%ebp;, by doing <code class="docutils literal notranslate"><span class="pre">pushl</span> <span class="pre">%ebp</span></code>. The base pointer is a
special register used for accessing function parameters and local
variables. Next, it copies the stack pointer to %ebp; by
doing <code class="docutils literal notranslate"><span class="pre">movl</span> <span class="pre">%esp,</span> <span class="pre">%ebp</span></code>. This allows you to be able to access the
function parameters as fixed indexes from the base pointer. You may
think that you can use the stack pointer for this. However, during your
program you may do other things with the stack such as pushing arguments
to other functions.</p>
<p>Copying the stack pointer into the base pointer at the beginning of a
function allows you to always know where your parameters are (and as we
will see, local variables too), even while you may be pushing things on
and off the stack. %ebp; will always be where the stack
pointer was at the beginning of the function, so it is more or less a
constant reference to the <em>stack frame</em> (the stack frame consists of all
of the stack variables used within a function, including parameters,
local variables, and the return address).</p>
<p>At this point, the stack looks like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Parameter</span> <span class="c1">#N   &lt;--- N*4+4(%ebp)</span>
<span class="o">...</span>
<span class="n">Parameter</span> <span class="mi">2</span>    <span class="o">&lt;---</span> <span class="mi">12</span><span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">)</span>
<span class="n">Parameter</span> <span class="mi">1</span>    <span class="o">&lt;---</span> <span class="mi">8</span><span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">)</span>
<span class="n">Return</span> <span class="n">Address</span> <span class="o">&lt;---</span> <span class="mi">4</span><span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">)</span>
<span class="n">Old</span> <span class="o">%</span><span class="n">ebp</span>       <span class="o">&lt;---</span> <span class="p">(</span><span class="o">%</span><span class="n">esp</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">)</span>
</pre></div>
</div>
<p>As you can see, each parameter can be accessed using base pointer
addressing mode using the %ebp; register.</p>
<p>Next, the function reserves space on the stack for any local variables
it needs. This is done by simply moving the stack pointer out of the
way. Let’s say that we are going to need two words of memory to run a
function. We can simply move the stack pointer down two words to reserve
the space. This is done like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>subl $8, %esp
</pre></div>
</div>
<p>This subtracts 8 from %esp; (remember, a word is four bytes
long). <a class="footnote-reference brackets" href="#id10" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a> This way, we can use the stack for variable storage without
worring about clobbering them with pushes that we may make for function
calls. Also, since it is allocated on the stack frame for this function
call, the variable will only be alive during this function. When we
return, the stack frame will go away, and so will these variables.
That’s why they are called local - they only exist while this function
is being called.</p>
<p>Now we have two words for local storage. Our stack now looks like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Parameter</span> <span class="c1">#N     &lt;--- N*4+4(%ebp)</span>
<span class="o">...</span>
<span class="n">Parameter</span> <span class="mi">2</span>      <span class="o">&lt;---</span> <span class="mi">12</span><span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">)</span>
<span class="n">Parameter</span> <span class="mi">1</span>      <span class="o">&lt;---</span> <span class="mi">8</span><span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">)</span>
<span class="n">Return</span> <span class="n">Address</span>   <span class="o">&lt;---</span> <span class="mi">4</span><span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">)</span>
<span class="n">Old</span> <span class="o">%</span><span class="n">ebp</span>         <span class="o">&lt;---</span> <span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">)</span>
<span class="n">Local</span> <span class="n">Variable</span> <span class="mi">1</span> <span class="o">&lt;---</span> <span class="o">-</span><span class="mi">4</span><span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">)</span>
<span class="n">Local</span> <span class="n">Variable</span> <span class="mi">2</span> <span class="o">&lt;---</span> <span class="o">-</span><span class="mi">8</span><span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="o">%</span><span class="n">esp</span><span class="p">)</span>
</pre></div>
</div>
<p>So we can now access all of the data we need for this function by using
base pointer addressing using different offsets from
%ebp;. %ebp; was made specifically for
this purpose, which is why it is called the base pointer. You can use
other registers in base pointer addressing mode, but the x86
architecture makes using the %ebp; register a lot faster.</p>
<p>Global variables and static variables are accessed just like the memory
we have been accessing memory in previous chapters. The only difference
between the global and static variables is that static variables are
only used by one function, while global variables are used by many
functions. Assembly language treats them exactly the same, although most
other languages distinguish them.</p>
<p>When a function is done executing, it does three things:</p>
<ol class="arabic simple">
<li><p>It stores its return value in %eax;.</p></li>
<li><p>It resets the stack to what it was when it was called (it gets rid of
the current stack frame and puts the stack frame of the calling code
back into effect).</p></li>
<li><p>It returns control back to wherever it was called from. This is done
using the <code class="docutils literal notranslate"><span class="pre">ret</span></code> instruction, which pops whatever value is at the
top of the stack, and sets the instruction pointer,
%eip;, to that value.</p></li>
</ol>
<p>So, before a function returns control to the code that called it, it
must restore the previous stack frame. Note also that without doing
this, <code class="docutils literal notranslate"><span class="pre">ret</span></code> wouldn’t work, because in our current stack frame, the
return address is not at the top of the stack. Therefore, before we
return, we have to reset the stack pointer %esp; and base
pointer %ebp; to what they were when the function began.</p>
<p>Therefore to return from the function you have to do the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">movl</span> <span class="o">%</span><span class="n">ebp</span><span class="p">,</span> <span class="o">%</span><span class="n">esp</span>
<span class="n">popl</span> <span class="o">%</span><span class="n">ebp</span>
<span class="n">ret</span>
</pre></div>
</div>
<p><em>At this point, you should consider all local variables to be disposed
of.</em> The reason is that after you move the stack pointer back, future
stack pushes will likely overwrite everything you put there. Therefore,
you should never save the address of a local variable past the life of
the function it was created in, or else it will be overwritten after the
life of its stack frame ends.</p>
<p>Control has now been handed back to the calling code, which can now
examine %eax; for the return value. The calling code also
needs to pop off all of the parameters it pushed onto the stack in order
to get the stack pointer back where it was (you can also simply add 4 *
number of parameters to %esp; using the <code class="docutils literal notranslate"><span class="pre">addl</span></code>
instruction, if you don’t need the values of the parameters
anymore). <a class="footnote-reference brackets" href="#id11" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a></p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>When you call a function, you should assume that everything currently
in your registers will be wiped out. The only register that is
guaranteed to be left with the value it started with are
%ebp; and a few others (the Linux C calling convention
requires functions to preserve the values of %ebx;,
%edi;, and %esi; if they are altered -
this is not strictly held during this book because these programs are
self-contained and not called by outside functions). %ebx;
also has some other uses in position-independent code, which is not
covered in this book. %eax; is guaranteed to be
overwritten with the return value, and the others likely are. If
there are registers you want to save before calling a function, you
need to save them by pushing them on the stack before pushing the
function’s parameters. You can then pop them back off in reverse
order after popping off the parameters. Even if you know a function
does not overwrite a register you should save it, because future
versions of that function may.</p>
<p>Note that in Linux assembly language, functions are</p>
<p>Other languages’ calling conventions may be different. For example,
other calling conventions may place the burden on the function to
save any registers it uses. Be sure to check to make sure the calling
conventions of your languages are compatible before trying to mix
languages. Or in the case of assembly language, be sure you know how
to call the other language’s functions.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Details of the C language calling convention (also known as the ABI,
or Application Binary Interface) is available online. We have
oversimplified and left out several important pieces to make this
simpler for new programmers. For full details, you should check out
the documents available at <a class="reference external" href="http://www.linuxbase.org/spec/refspecs/">http://www.linuxbase.org/spec/refspecs/</a>
Specifically, you should look for the System V Application Binary
Interface - Intel386 Architecture Processor Supplement.</p>
</div>
</section>
<section id="a-function-example">
<h2>A Function Example<a class="headerlink" href="#a-function-example" title="Link to this heading">¶</a></h2>
<p>Let’s take a look at how a function call works in a real program. The
function we are going to write is the <code class="docutils literal notranslate"><span class="pre">power</span></code> function. We will give
the power function two parameters - the number and the power we want to
raise it to. For example, if we gave it the parameters 2 and 3, it would
raise 2 to the power of 3, or 2*2*2, giving 8. In order to make this
program simple, we will only allow numbers 1 and greater.</p>
<p>The following is the code for the complete program. As usual, an
explanation follows. Name the file <code class="docutils literal notranslate"><span class="pre">power.s</span></code>.</p>
<div class="literal-block-wrapper docutils container" id="id13">
<div class="code-block-caption"><span class="caption-text">src/power.s</span><a class="headerlink" href="#id13" title="Link to this code">¶</a></div>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="w">	</span><span class="c1">#PURPOSE:  Program to illustrate how functions work</span>
<span class="linenos"> 2</span><span class="w">	</span><span class="c1">#          This program will compute the value of</span>
<span class="linenos"> 3</span><span class="w">	</span><span class="c1">#          2^3 + 5^2</span>
<span class="linenos"> 4</span><span class="w">	</span><span class="c1">#</span>
<span class="linenos"> 5</span>
<span class="linenos"> 6</span><span class="w">	</span><span class="c1">#Everything in the main program is stored in registers,</span>
<span class="linenos"> 7</span><span class="w">	</span><span class="c1">#so the data section doesn&#39;t have anything.</span>
<span class="linenos"> 8</span><span class="w">	</span><span class="na">.section</span><span class="w"> </span><span class="no">.data</span><span class="w"> </span>
<span class="linenos"> 9</span>
<span class="linenos">10</span><span class="w">	</span><span class="no">.section</span><span class="w"> </span><span class="no">.text</span>
<span class="linenos">11</span>
<span class="linenos">12</span><span class="w">	</span><span class="na">.globl</span><span class="w"> </span><span class="no">_start</span>
<span class="linenos">13</span><span class="nl">_start:</span>
<span class="linenos">14</span><span class="w">	</span><span class="nf">pushl</span><span class="w"> </span><span class="no">$3</span><span class="w">                  </span><span class="c1">#push second argument</span>
<span class="linenos">15</span><span class="w">	</span><span class="nf">pushl</span><span class="w"> </span><span class="no">$2</span><span class="w">                  </span><span class="c1">#push first argument</span>
<span class="linenos">16</span><span class="w">	</span><span class="nf">call</span><span class="w">  </span><span class="no">power</span><span class="w">               </span><span class="c1">#call the function</span>
<span class="linenos">17</span><span class="w">	</span><span class="nf">addl</span><span class="w">  </span><span class="no">$8</span><span class="p">,</span><span class="w"> </span><span class="nv">%esp</span><span class="w">            </span><span class="c1">#move the stack pointer back</span>
<span class="linenos">18</span>
<span class="linenos">19</span><span class="w">	</span><span class="nf">pushl</span><span class="w"> </span><span class="nv">%eax</span><span class="w">                </span><span class="c1">#save the first answer before</span>
<span class="linenos">20</span><span class="w">	                          </span><span class="c1">#calling the next function</span>
<span class="linenos">21</span>
<span class="linenos">22</span><span class="w">	</span><span class="nf">pushl</span><span class="w"> </span><span class="no">$2</span><span class="w">                  </span><span class="c1">#push second argument</span>
<span class="linenos">23</span><span class="w">	</span><span class="nf">pushl</span><span class="w"> </span><span class="no">$5</span><span class="w">                  </span><span class="c1">#push first argument</span>
<span class="linenos">24</span><span class="w">	</span><span class="nf">call</span><span class="w">  </span><span class="no">power</span><span class="w">               </span><span class="c1">#call the function</span>
<span class="linenos">25</span><span class="w">	</span><span class="nf">addl</span><span class="w">  </span><span class="no">$8</span><span class="p">,</span><span class="w"> </span><span class="nv">%esp</span><span class="w">            </span><span class="c1">#move the stack pointer back</span>
<span class="linenos">26</span>
<span class="linenos">27</span><span class="w">	</span><span class="nf">popl</span><span class="w">  </span><span class="nv">%ebx</span><span class="w">                </span><span class="c1">#The second answer is already</span>
<span class="linenos">28</span><span class="w">	                          </span><span class="c1">#in %eax.  We saved the </span>
<span class="linenos">29</span><span class="w">	                          </span><span class="c1">#first answer onto the stack,</span>
<span class="linenos">30</span><span class="w">	                          </span><span class="c1">#so now we can just pop it</span>
<span class="linenos">31</span><span class="w">	                          </span><span class="c1">#out into %ebx</span>
<span class="linenos">32</span>
<span class="linenos">33</span><span class="w">	</span><span class="nf">addl</span><span class="w">  </span><span class="nv">%eax</span><span class="p">,</span><span class="w"> </span><span class="nv">%ebx</span><span class="w">          </span><span class="c1">#add them together</span>
<span class="linenos">34</span><span class="w">	                          </span><span class="c1">#the result is in %ebx</span>
<span class="linenos">35</span><span class="w">	</span>
<span class="linenos">36</span><span class="w">	</span><span class="nf">movl</span><span class="w">  </span><span class="no">$1</span><span class="p">,</span><span class="w"> </span><span class="nv">%eax</span><span class="w">            </span><span class="c1">#exit (%ebx is returned)</span>
<span class="linenos">37</span><span class="w">	</span><span class="nf">int</span><span class="w">   </span><span class="no">$0x80</span>
<span class="linenos">38</span>
<span class="linenos">39</span><span class="w">	</span><span class="c1">#PURPOSE:  This function is used to compute</span>
<span class="linenos">40</span><span class="w">	</span><span class="c1">#          the value of a number raised to</span>
<span class="linenos">41</span><span class="w">	</span><span class="c1">#          a power.</span>
<span class="linenos">42</span><span class="w">	</span><span class="c1">#</span>
<span class="linenos">43</span><span class="w">	</span><span class="c1">#INPUT:    First argument - the base number</span>
<span class="linenos">44</span><span class="w">	</span><span class="c1">#          Second argument - the power to </span>
<span class="linenos">45</span><span class="w">	</span><span class="c1">#                            raise it to</span>
<span class="linenos">46</span><span class="w">	</span><span class="c1">#</span>
<span class="linenos">47</span><span class="w">	</span><span class="c1">#OUTPUT:   Will give the result as a return value</span>
<span class="linenos">48</span><span class="w">	</span><span class="c1">#</span>
<span class="linenos">49</span><span class="w">	</span><span class="c1">#NOTES:    The power must be 1 or greater</span>
<span class="linenos">50</span><span class="w">	</span><span class="c1">#</span>
<span class="linenos">51</span><span class="w">	</span><span class="c1">#VARIABLES: </span>
<span class="linenos">52</span><span class="w">	</span><span class="c1">#          %ebx - holds the base number</span>
<span class="linenos">53</span><span class="w">	</span><span class="c1">#          %ecx - holds the power</span>
<span class="linenos">54</span><span class="w">	</span><span class="c1">#</span>
<span class="linenos">55</span><span class="w">	</span><span class="c1">#          -4(%ebp) - holds the current result</span>
<span class="linenos">56</span><span class="w">	</span><span class="c1">#</span>
<span class="linenos">57</span><span class="w">	</span><span class="c1">#          %eax is used for temporary storage</span>
<span class="linenos">58</span><span class="w">	</span><span class="c1">#</span>
<span class="linenos">59</span><span class="w">	</span><span class="na">.type</span><span class="w"> </span><span class="no">power</span><span class="p">,</span><span class="w"> </span><span class="na">@function</span>
<span class="linenos">60</span><span class="nl">power:</span>
<span class="linenos">61</span><span class="w">	</span><span class="nf">pushl</span><span class="w"> </span><span class="nv">%ebp</span><span class="w">           </span><span class="c1">#save old base pointer</span>
<span class="linenos">62</span><span class="w">	</span><span class="nf">movl</span><span class="w">  </span><span class="nv">%esp</span><span class="p">,</span><span class="w"> </span><span class="nv">%ebp</span><span class="w">     </span><span class="c1">#make stack pointer the base pointer</span>
<span class="linenos">63</span><span class="w">	</span><span class="nf">subl</span><span class="w">  </span><span class="no">$4</span><span class="p">,</span><span class="w"> </span><span class="nv">%esp</span><span class="w">       </span><span class="c1">#get room for our local storage</span>
<span class="linenos">64</span>
<span class="linenos">65</span><span class="w">	</span><span class="nf">movl</span><span class="w">  </span><span class="mi">8</span><span class="p">(</span><span class="nv">%ebp</span><span class="p">),</span><span class="w"> </span><span class="nv">%ebx</span><span class="w">  </span><span class="c1">#put first argument in %ebx</span>
<span class="linenos">66</span><span class="w">	</span><span class="nf">movl</span><span class="w">  </span><span class="mi">12</span><span class="p">(</span><span class="nv">%ebp</span><span class="p">),</span><span class="w"> </span><span class="nv">%ecx</span><span class="w"> </span><span class="c1">#put second argument in %ecx</span>
<span class="linenos">67</span>
<span class="linenos">68</span><span class="w">	</span><span class="nf">movl</span><span class="w">  </span><span class="nv">%ebx</span><span class="p">,</span><span class="w"> </span><span class="mi">-4</span><span class="p">(</span><span class="nv">%ebp</span><span class="p">)</span><span class="w"> </span><span class="c1">#store current result</span>
<span class="linenos">69</span>
<span class="linenos">70</span><span class="nl">power_loop_start:</span>
<span class="linenos">71</span><span class="w">	</span><span class="nf">cmpl</span><span class="w">  </span><span class="no">$1</span><span class="p">,</span><span class="w"> </span><span class="nv">%ecx</span><span class="w">       </span><span class="c1">#if the power is 1, we are done</span>
<span class="linenos">72</span><span class="w">	</span><span class="nf">je</span><span class="w">    </span><span class="no">end_power</span>
<span class="linenos">73</span><span class="w">	</span><span class="nf">movl</span><span class="w">  </span><span class="mi">-4</span><span class="p">(</span><span class="nv">%ebp</span><span class="p">),</span><span class="w"> </span><span class="nv">%eax</span><span class="w"> </span><span class="c1">#move the current result into %eax</span>
<span class="linenos">74</span><span class="w">	</span><span class="nf">imull</span><span class="w"> </span><span class="nv">%ebx</span><span class="p">,</span><span class="w"> </span><span class="nv">%eax</span><span class="w">     </span><span class="c1">#multiply the current result by</span>
<span class="linenos">75</span><span class="w">	                     </span><span class="c1">#the base number</span>
<span class="linenos">76</span><span class="w">	</span><span class="nf">movl</span><span class="w">  </span><span class="nv">%eax</span><span class="p">,</span><span class="w"> </span><span class="mi">-4</span><span class="p">(</span><span class="nv">%ebp</span><span class="p">)</span><span class="w"> </span><span class="c1">#store the current result </span>
<span class="linenos">77</span>
<span class="linenos">78</span><span class="w">	</span><span class="nf">decl</span><span class="w">  </span><span class="nv">%ecx</span><span class="w">           </span><span class="c1">#decrease the power</span>
<span class="linenos">79</span><span class="w">	</span><span class="nf">jmp</span><span class="w">   </span><span class="no">power_loop_start</span><span class="w"> </span><span class="c1">#run for the next power</span>
<span class="linenos">80</span>
<span class="linenos">81</span><span class="nl">end_power:</span>
<span class="linenos">82</span><span class="w">	</span><span class="nf">movl</span><span class="w"> </span><span class="mi">-4</span><span class="p">(</span><span class="nv">%ebp</span><span class="p">),</span><span class="w"> </span><span class="nv">%eax</span><span class="w">  </span><span class="c1">#return value goes in %eax</span>
<span class="linenos">83</span><span class="w">	</span><span class="nf">movl</span><span class="w"> </span><span class="nv">%ebp</span><span class="p">,</span><span class="w"> </span><span class="nv">%esp</span><span class="w">      </span><span class="c1">#restore the stack pointer</span>
<span class="linenos">84</span><span class="w">	</span><span class="nf">popl</span><span class="w"> </span><span class="nv">%ebp</span><span class="w">            </span><span class="c1">#restore the base pointer</span>
<span class="linenos">85</span><span class="w">	</span><span class="nf">ret</span>
</pre></div>
</div>
</div>
<p>Type in the program, assemble it, and run it. Try calling power for
different values, but remember that the result has to be less than 256
when it is passed back to the operating system. Also try subtracting the
results of the two computations. Try adding a third call to the
<code class="docutils literal notranslate"><span class="pre">power</span></code> function, and add its result back in.</p>
<p>The main program code is pretty simple. You push the arguments onto the
stack, call the function, and then move the stack pointer back. The
result is stored in %eax;. Note that between the two calls to
<code class="docutils literal notranslate"><span class="pre">power</span></code>, we save the first value onto the stack. This is because the
only register that is guaranteed to be saved is %ebp;.
Therefore we push the value onto the stack, and pop the value back off
after the second function call is complete.</p>
<p>Let’s look at how the function itself is written. Notice that before the
function, there is documentation as to what the function does, what its
arguments are, and what it gives as a return value. This is useful for
programmers who use this function. This is the function’s interface.
This lets the programmer know what values are needed on the stack, and
what will be in %eax; at the end.</p>
<p>We then have the following line:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">.</span><span class="n">type</span> <span class="n">power</span><span class="p">,</span><span class="nd">@function</span>
</pre></div>
</div>
<p>This tells the linker that the symbol <code class="docutils literal notranslate"><span class="pre">power</span></code> should be treated as a
function. Since this program is only in one file, it would work just the
same with this left out. However, it is good practice.</p>
<p>After that, we define the value of the <code class="docutils literal notranslate"><span class="pre">power</span></code> label:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">power</span><span class="p">:</span>
</pre></div>
</div>
<p>As mentioned previously, this defines the symbol <code class="docutils literal notranslate"><span class="pre">power</span></code> to be the
address where the instructions following the label begin. This is how
<code class="docutils literal notranslate"><span class="pre">call</span> <span class="pre">power</span></code> works. It transfers control to this spot of the program.
The difference between <code class="docutils literal notranslate"><span class="pre">call</span></code> and <code class="docutils literal notranslate"><span class="pre">jmp</span></code> is that <code class="docutils literal notranslate"><span class="pre">call</span></code> also
pushes the return address onto the stack so that the function can
return, while the <code class="docutils literal notranslate"><span class="pre">jmp</span></code> does not.</p>
<p>Next, we have our instructions to set up our function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>pushl %ebp
movl  %esp, %ebp
subl  $4, %esp
</pre></div>
</div>
<p>At this point, our stack looks like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Base</span> <span class="n">Number</span>    <span class="o">&lt;---</span> <span class="mi">12</span><span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">)</span>
<span class="n">Power</span>          <span class="o">&lt;---</span> <span class="mi">8</span><span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">)</span>
<span class="n">Return</span> <span class="n">Address</span> <span class="o">&lt;---</span> <span class="mi">4</span><span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">)</span>
<span class="n">Old</span> <span class="o">%</span><span class="n">ebp</span>       <span class="o">&lt;---</span> <span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">)</span>
<span class="n">Current</span> <span class="n">result</span> <span class="o">&lt;---</span> <span class="o">-</span><span class="mi">4</span><span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="o">%</span><span class="n">esp</span><span class="p">)</span>
</pre></div>
</div>
<p>Although we could use a register for temporary storage, this program
uses a local variable in order to show how to set it up. Often times
there just aren’t enough registers to store everything, so you have to
offload them into local variables. Other times, your function will need
to call another function and send it a pointer to some of your data. You
can’t have a pointer to a register, so you have to store it in a local
variable in order to send a pointer to it.</p>
<p>Basically, what the program does is start with the base number, and
store it both as the multiplier (stored in %ebx;) and the current
value (stored in -4(%ebp)). It also has the power stored in %ecx;
It then continually multiplies the current value by the multiplier,
decreases the power, and leaves the loop if the power (in %ecx;)
gets down to 1.</p>
<p>By now, you should be able to go through the program without help. The
only things you should need to know is that <code class="docutils literal notranslate"><span class="pre">imull</span></code> does integer
multiplication and stores the result in the second operand, and
<code class="docutils literal notranslate"><span class="pre">decl</span></code> decreases the given register by 1. For more information on
these and other instructions, see <a class="reference internal" href="instructionsap.html#instructionsappendix"><span class="std std-ref">Common x86 Instructions</span></a></p>
<p>A good project to try now is to extend the program so it will return the
value of a number if the power is 0 (hint, anything raised to the zero
power is 1). Keep trying. If it doesn’t work at first, try going through
your program by hand with a scrap of paper, keeping track of where
%ebp; and %esp; are pointing, what is on the stack, and
what the values are in each register.</p>
</section>
<section id="recursive-functions">
<span id="recursivefunctions"></span><h2>Recursive Functions<a class="headerlink" href="#recursive-functions" title="Link to this heading">¶</a></h2>
<p>The next program will stretch your brains even more. The program will
compute the <em>factorial</em> of a number. A factorial is the product of a
number and all the numbers between it and one. For example, the
factorial of 7 is 7*6*5*4*3*2*1, and the factorial of 4 is 4*3*2*1. Now,
one thing you might notice is that the factorial of a number is the same
as the product of a number and the factorial just below it. For example,
the factorial of 4 is 4 times the factorial of 3. The factorial of 3 is
3 times the factorial of 2. 2 is 2 times the factorial of 1. The
factorial of 1 is 1. This type of definition is called a recursive
definition. That means, the definition of the factorial function
includes the factorial function itself. However, since all functions
need to end, a recursive definition must include a <em>base case</em>. The base
case is the point where recursion will stop. Without a base case, the
function would go on forever calling itself until it eventually ran out
of stack space. In the case of the factorial, the base case is the
number 1. When we hit the number 1, we don’t run the factorial again, we
just say that the factorial of 1 is 1. So, let’s run through what we
want the code to look like for our factorial function:</p>
<ol class="arabic simple">
<li><p>Examine the number</p></li>
<li><p>Is the number 1?</p></li>
<li><p>If so, the answer is one</p></li>
<li><p>Otherwise, the answer is the number times the factorial of the number
minus one</p></li>
</ol>
<p>This would be problematic if we didn’t have local variables. In other
programs, storing values in global variables worked fine. However,
global variables only provide one copy of each variable. In this
program, we will have multiple copies of the function running at the
same time, all of them needing their own copies of the data! <a class="footnote-reference brackets" href="#id12" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a> Since
local variables exist on the stack frame, and each function call gets
its own stack frame, we are okay.</p>
<p>Let’s look at the code to see how this works:</p>
<div class="literal-block-wrapper docutils container" id="id14">
<div class="code-block-caption"><span class="caption-text">src/factorial.s</span><a class="headerlink" href="#id14" title="Link to this code">¶</a></div>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="w">	</span><span class="c1">#PURPOSE - Given a number, this program computes the</span>
<span class="linenos"> 2</span><span class="w">	</span><span class="c1">#          factorial.  For example, the factorial of</span>
<span class="linenos"> 3</span><span class="w">	</span><span class="c1">#          3 is 3 * 2 * 1, or 6.  The factorial of</span>
<span class="linenos"> 4</span><span class="w">	</span><span class="c1">#          4 is 4 * 3 * 2 * 1, or 24, and so on.</span>
<span class="linenos"> 5</span><span class="w">	</span><span class="c1">#</span>
<span class="linenos"> 6</span>
<span class="linenos"> 7</span><span class="w">	</span><span class="c1">#This program shows how to call a function recursively. </span>
<span class="linenos"> 8</span>
<span class="linenos"> 9</span><span class="w">	</span><span class="na">.section</span><span class="w"> </span><span class="no">.data</span>
<span class="linenos">10</span>
<span class="linenos">11</span><span class="w">	</span><span class="c1">#This program has no global data</span>
<span class="linenos">12</span>
<span class="linenos">13</span><span class="w">	</span><span class="na">.section</span><span class="w"> </span><span class="no">.text</span>
<span class="linenos">14</span>
<span class="linenos">15</span><span class="w">	</span><span class="na">.globl</span><span class="w"> </span><span class="no">_start</span>
<span class="linenos">16</span><span class="w">	</span><span class="na">.globl</span><span class="w"> </span><span class="no">factorial</span><span class="w"> </span><span class="c1">#this is unneeded unless we want to share</span>
<span class="linenos">17</span><span class="w">	                 </span><span class="c1">#this function among other programs</span>
<span class="linenos">18</span><span class="nl">_start:</span>
<span class="linenos">19</span><span class="w">	</span><span class="nf">pushl</span><span class="w"> </span><span class="no">$4</span><span class="w">         </span><span class="c1">#The factorial takes one argument - the </span>
<span class="linenos">20</span><span class="w">	                 </span><span class="c1">#number we want a factorial of.  So, it</span>
<span class="linenos">21</span><span class="w">	                 </span><span class="c1">#gets pushed</span>
<span class="linenos">22</span><span class="w">	</span><span class="nf">call</span><span class="w">  </span><span class="no">factorial</span><span class="w">  </span><span class="c1">#run the factorial function</span>
<span class="linenos">23</span><span class="w">	</span><span class="nf">addl</span><span class="w">  </span><span class="no">$4</span><span class="p">,</span><span class="w"> </span><span class="nv">%esp</span><span class="w">   </span><span class="c1">#Scrubs the parameter that was pushed on </span>
<span class="linenos">24</span><span class="w">	                 </span><span class="c1">#the stack</span>
<span class="linenos">25</span><span class="w">	</span><span class="nf">movl</span><span class="w">  </span><span class="nv">%eax</span><span class="p">,</span><span class="w"> </span><span class="nv">%ebx</span><span class="w"> </span><span class="c1">#factorial returns the answer in %eax, but </span>
<span class="linenos">26</span><span class="w">	                 </span><span class="c1">#we want it in %ebx to send it as our exit </span>
<span class="linenos">27</span><span class="w">	                 </span><span class="c1">#status</span>
<span class="linenos">28</span><span class="w">	</span><span class="nf">movl</span><span class="w">  </span><span class="no">$1</span><span class="p">,</span><span class="w"> </span><span class="nv">%eax</span><span class="w">   </span><span class="c1">#call the kernel&#39;s exit function</span>
<span class="linenos">29</span><span class="w">	</span><span class="nf">int</span><span class="w">   </span><span class="no">$0x80</span>
<span class="linenos">30</span>
<span class="linenos">31</span>
<span class="linenos">32</span><span class="w">	</span><span class="c1">#This is the actual function definition</span>
<span class="linenos">33</span><span class="w">	</span><span class="na">.type</span><span class="w"> </span><span class="no">factorial</span><span class="p">,</span><span class="na">@function</span>
<span class="linenos">34</span><span class="nl">factorial:</span>
<span class="linenos">35</span><span class="w">	</span><span class="nf">pushl</span><span class="w"> </span><span class="nv">%ebp</span><span class="w">       </span><span class="c1">#standard function stuff - we have to </span>
<span class="linenos">36</span><span class="w">	                 </span><span class="c1">#restore %ebp to its prior state before </span>
<span class="linenos">37</span><span class="w">	                 </span><span class="c1">#returning, so we have to push it</span>
<span class="linenos">38</span><span class="w">	</span><span class="nf">movl</span><span class="w">  </span><span class="nv">%esp</span><span class="p">,</span><span class="w"> </span><span class="nv">%ebp</span><span class="w"> </span><span class="c1">#This is because we don&#39;t want to modify</span>
<span class="linenos">39</span><span class="w">	                 </span><span class="c1">#the stack pointer, so we use %ebp.</span>
<span class="linenos">40</span>
<span class="linenos">41</span><span class="w">	</span><span class="nf">movl</span><span class="w">  </span><span class="mi">8</span><span class="p">(</span><span class="nv">%ebp</span><span class="p">),</span><span class="w"> </span><span class="nv">%eax</span><span class="w"> </span><span class="c1">#This moves the first argument to %eax</span>
<span class="linenos">42</span><span class="w">	                 </span><span class="c1">#4(%ebp) holds the return address, and</span>
<span class="linenos">43</span><span class="w">	                 </span><span class="c1">#8(%ebp) holds the first parameter</span>
<span class="linenos">44</span><span class="w">	</span><span class="nf">cmpl</span><span class="w">  </span><span class="no">$1</span><span class="p">,</span><span class="w"> </span><span class="nv">%eax</span><span class="w">      </span><span class="c1">#If the number is 1, that is our base </span>
<span class="linenos">45</span><span class="w">	                    </span><span class="c1">#case, and we simply return (1 is </span>
<span class="linenos">46</span><span class="w">	                    </span><span class="c1">#already in %eax as the return value)</span>
<span class="linenos">47</span><span class="w">	</span><span class="nf">je</span><span class="w"> </span><span class="no">end_factorial</span><span class="w">    </span>
<span class="linenos">48</span><span class="w">	</span><span class="no">decl</span><span class="w">  </span><span class="nv">%eax</span><span class="w">          </span><span class="c1">#otherwise, decrease the value</span>
<span class="linenos">49</span><span class="w">	</span><span class="nf">pushl</span><span class="w"> </span><span class="nv">%eax</span><span class="w">          </span><span class="c1">#push it for our call to factorial</span>
<span class="linenos">50</span><span class="w">	</span><span class="nf">call</span><span class="w">  </span><span class="no">factorial</span><span class="w">     </span><span class="c1">#call factorial</span>
<span class="linenos">51</span><span class="w">	</span><span class="nf">movl</span><span class="w">  </span><span class="mi">8</span><span class="p">(</span><span class="nv">%ebp</span><span class="p">),</span><span class="w"> </span><span class="nv">%ebx</span><span class="w"> </span><span class="c1">#%eax has the return value, so we </span>
<span class="linenos">52</span><span class="w">	                    </span><span class="c1">#reload our parameter into %ebx</span>
<span class="linenos">53</span><span class="w">	</span><span class="nf">imull</span><span class="w"> </span><span class="nv">%ebx</span><span class="p">,</span><span class="w"> </span><span class="nv">%eax</span><span class="w">    </span><span class="c1">#multiply that by the result of the</span>
<span class="linenos">54</span><span class="w">	                    </span><span class="c1">#last call to factorial (in %eax)</span>
<span class="linenos">55</span><span class="w">	                    </span><span class="c1">#the answer is stored in %eax, which </span>
<span class="linenos">56</span><span class="w">	                    </span><span class="c1">#is good since that&#39;s where return </span>
<span class="linenos">57</span><span class="w">	                    </span><span class="c1">#values go.</span>
<span class="linenos">58</span><span class="nl">end_factorial:</span>
<span class="linenos">59</span><span class="w">	</span><span class="nf">movl</span><span class="w">  </span><span class="nv">%ebp</span><span class="p">,</span><span class="w"> </span><span class="nv">%esp</span><span class="w">    </span><span class="c1">#standard function return stuff - we</span>
<span class="linenos">60</span><span class="w">	</span><span class="nf">popl</span><span class="w">  </span><span class="nv">%ebp</span><span class="w">          </span><span class="c1">#have to restore %ebp and %esp to where</span>
<span class="linenos">61</span><span class="w">	                    </span><span class="c1">#they were before the function started</span>
<span class="linenos">62</span><span class="w">	</span><span class="nf">ret</span><span class="w">                 </span><span class="c1">#return from the function (this pops the </span>
<span class="linenos">63</span><span class="w">	                    </span><span class="c1">#return value, too)</span>
<span class="linenos">64</span><span class="w">	</span>
</pre></div>
</div>
</div>
<p>Assemble, link, and run it with these commands:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>as factorial.s -o factorial.o
ld factorial.o -o factorial
./factorial
echo $?
</pre></div>
</div>
<p>This should give you the value 24. 24 is the factorial of 4, you can
test it out yourself with a calculator: 4 * 3 * 2 * 1 = 24.</p>
<p>I’m guessing you didn’t understand the whole code listing. Let’s go
through it a line at a time to see what is happening.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>_start:
    pushl $4
    call factorial
</pre></div>
</div>
<p>Okay, this program is intended to compute the factorial of the number 4.
When programming functions, you are supposed to put the parameters of
the function on the top of the stack right before you call it. Remember,
a function’s <em>parameters</em> are the data that you want the function to
work with. In this case, the factorial function takes 1 parameter - the
number you want the factorial of.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">pushl</span></code> instruction puts the given value at the top of the
stack. The <code class="docutils literal notranslate"><span class="pre">call</span></code> instruction then makes the function call.</p>
<p>Next we have these lines:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>addl  $4, %esp
movl  %eax, %ebx
movl  $1, %eax
int   $0x80
</pre></div>
</div>
<p>This takes place after <code class="docutils literal notranslate"><span class="pre">factorial</span></code> has finished and computed the
factorial of 4 for us. Now we have to clean up the stack. The <code class="docutils literal notranslate"><span class="pre">addl</span></code>
instruction moves the stack pointer back to where it was before we
pushed the <code class="docutils literal notranslate"><span class="pre">$4</span></code> onto the stack. You should always clean up your stack
parameters after a function call returns.</p>
<p>The next instruction moves %eax; to %ebx;. What’s in
%eax;? It is <code class="docutils literal notranslate"><span class="pre">factorial</span></code>’s return value. In our case,
it is the value of the factorial function. With 4 as our parameter, 24
should be our return value. Remember, return values are always stored in
%eax;. We want to return this value as the status code to
the operating system. However, Linux requires that the program’s exit
status be stored in %ebx;, not %eax;, so we have
to move it. Then we do the standard exit system call.</p>
<p>The nice thing about function calls is that:</p>
<ul class="simple">
<li><p>Other programmers don’t have to know anything about them except its
arguments to use them.</p></li>
<li><p>They provide standardized building blocks from which you can form a
program.</p></li>
<li><p>They can be called multiple times and from multiple locations and
they always know how to get back to where they were since
<code class="docutils literal notranslate"><span class="pre">call</span></code> pushes the return address onto the stack.</p></li>
</ul>
<p>These are the main advantages of functions. Larger programs also use
functions to break down complex pieces of code into smaller, simpler
ones. In fact, almost all of programming is writing and calling
functions.</p>
<p>Let’s now take a look at how the <code class="docutils literal notranslate"><span class="pre">factorial</span></code> function itself is
implemented.</p>
<p>Before the function starts, we have this directive:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="o">.</span><span class="n">type</span> <span class="n">factorial</span><span class="p">,</span><span class="nd">@function</span>
<span class="n">factorial</span><span class="p">:</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">.type</span></code> directive tells the linker that <code class="docutils literal notranslate"><span class="pre">factorial</span></code> is a
function. This isn’t really needed unless we were using <code class="docutils literal notranslate"><span class="pre">factorial</span></code> in
other programs. We have included it for completeness. The line that says
<code class="docutils literal notranslate"><span class="pre">factorial:</span></code> gives the symbol <code class="docutils literal notranslate"><span class="pre">factorial</span></code> the storage location of
the next instruction. That’s how <code class="docutils literal notranslate"><span class="pre">call</span></code> knew where to go when we said
<code class="docutils literal notranslate"><span class="pre">call</span> <span class="pre">factorial</span></code>.</p>
<p>The first real instructions of the function are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pushl</span> <span class="o">%</span><span class="n">ebp</span>
<span class="n">movl</span>  <span class="o">%</span><span class="n">esp</span><span class="p">,</span> <span class="o">%</span><span class="n">ebp</span>
</pre></div>
</div>
<p>As shown in the previous program, this creates the stack frame for this
function. These two lines will be the way you should start every
function.</p>
<p>The next instruction is this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">movl</span>  <span class="mi">8</span><span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">),</span> <span class="o">%</span><span class="n">eax</span>
</pre></div>
</div>
<p>This uses base pointer addressing to move the first parameter of the
function into %eax;. Remember, <code class="docutils literal notranslate"><span class="pre">(%ebp)</span></code> has the old
%ebp;, <code class="docutils literal notranslate"><span class="pre">4(%ebp)</span></code> has the return address, and <code class="docutils literal notranslate"><span class="pre">8(%ebp)</span></code> is the
location of the first parameter to the function. If you think back, this
will be the value 4 on the first call, since that was what we pushed on
the stack before calling the function the first time (with
<code class="docutils literal notranslate"><span class="pre">pushl</span> <span class="pre">$4</span></code>). As this function calls itself, it will have other values,
too.</p>
<p>Next, we check to see if we’ve hit our base case (a parameter of 1). If
so, we jump to the instruction at the label <code class="docutils literal notranslate"><span class="pre">end_factorial</span></code>, where it
will be returned. It’s already in %eax; which we mentioned
earlier is where you put return values. That is accomplished by these
lines:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>cmpl $1, %eax
je end_factorial
</pre></div>
</div>
<p>If it’s not our base case, what did we say we would do? We would call
the <code class="docutils literal notranslate"><span class="pre">factorial</span></code> function again with our parameter minus one. So, first
we decrease %eax; by one:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">decl</span> <span class="o">%</span><span class="n">eax</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">decl</span></code> stands for decrement. It subtracts 1 from the given
register or memory location (%eax; in our case). <code class="docutils literal notranslate"><span class="pre">incl</span></code> is
the inverse - it adds 1. After decrementing %eax; we push it onto
the stack since it’s going to be the parameter of the next function
call. And then we call <code class="docutils literal notranslate"><span class="pre">factorial</span></code> again!</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pushl</span> <span class="o">%</span><span class="n">eax</span>
<span class="n">call</span> <span class="n">factorial</span>
</pre></div>
</div>
<p>Okay, now we’ve called <code class="docutils literal notranslate"><span class="pre">factorial</span></code>. One thing to remember is that
after a function call, we can never know what the registers are (except
<code class="docutils literal notranslate"><span class="pre">%esp</span></code> and <code class="docutils literal notranslate"><span class="pre">%ebp</span></code>). So even though we had the value we were called
with in <code class="docutils literal notranslate"><span class="pre">%eax</span></code>, it’s not there any more. Therefore, we need pull it
off the stack from the same place we got it the first time (at
<code class="docutils literal notranslate"><span class="pre">8(%ebp)</span></code>). So, we do this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">movl</span> <span class="mi">8</span><span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">),</span> <span class="o">%</span><span class="n">ebx</span>
</pre></div>
</div>
<p>Now, we want to multiply that number with the result of the factorial
function. If you remember our previous discussion, the result of
functions are left in %eax;. So, we need to multiply %ebx;
with %eax;. This is done with this instruction:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">imull</span> <span class="o">%</span><span class="n">ebx</span><span class="p">,</span> <span class="o">%</span><span class="n">eax</span>
</pre></div>
</div>
<p>This also stores the result in %eax;, which is exactly where we
want the return value for the function to be! Since the return value is
in place we just need to leave the function. If you remember, at the
start of the function we pushed %ebp;, and moved %esp;
into %ebp; to create the current stack frame. Now we reverse the
operation to destroy the current stack frame and reactivate the last
one:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">end_factorial</span><span class="p">:</span>
    <span class="n">movl</span> <span class="o">%</span><span class="n">ebp</span><span class="p">,</span> <span class="o">%</span><span class="n">esp</span>
    <span class="n">popl</span> <span class="o">%</span><span class="n">ebp</span>
</pre></div>
</div>
<p>Now we’re already to return, so we issue the following command</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ret</span>
</pre></div>
</div>
<p>This pops the top value off of the stack, and then jumps to it. If you
remember our discussion about <code class="docutils literal notranslate"><span class="pre">call</span></code>, we said that <code class="docutils literal notranslate"><span class="pre">call</span></code> first
pushed the address of the next instruction onto the stack before it
jumped to the beginning of the function. So, here we pop it back off so
we can return there. The function is done, and we have our answer!</p>
<p>Like our previous program, you should look over the program again, and
make sure you know what everything does. Look back through this section
and the previous sections for the explanation of anything you don’t
understand. Then, take a piece of paper, and go through the program
step-by-step, keeping track of what the values of the registers are at
each step, and what values are on the stack. Doing this should deepen
your understanding of what is going on.</p>
</section>
<section id="review">
<h2>Review<a class="headerlink" href="#review" title="Link to this heading">¶</a></h2>
<section id="know-the-concepts">
<h3>Know the Concepts<a class="headerlink" href="#know-the-concepts" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>What are primitives?</p></li>
<li><p>What are calling conventions?</p></li>
<li><p>What is the stack?</p></li>
<li><p>How do <code class="docutils literal notranslate"><span class="pre">pushl</span></code> and <code class="docutils literal notranslate"><span class="pre">popl</span></code> affect the stack? What special-purpose
register do they affect?</p></li>
<li><p>What are local variables and what are they used for?</p></li>
<li><p>Why are local variables so necessary in recursive functions?</p></li>
<li><p>What are %ebp; and %esp; used for?</p></li>
<li><p>What is a stack frame?</p></li>
</ul>
</section>
<section id="use-the-concepts">
<span id="functionsreviewuseconcepts"></span><h3>Use the Concepts<a class="headerlink" href="#use-the-concepts" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>Write a function called <code class="docutils literal notranslate"><span class="pre">square</span></code> which receives one argument and
returns the square of that argument.</p></li>
<li><p>Write a program to test your <code class="docutils literal notranslate"><span class="pre">square</span></code> function.</p></li>
<li><p>Convert the maximum program given in <a class="reference internal" href="firstprog.html#maximum"><span class="std std-ref">Finding a Maximum Value</span></a> so that it is
a function which takes a pointer to several values and returns their
maximum. Write a program that calls maximum with 3 different lists,
and returns the result of the last one as the program’s exit status
code.</p></li>
<li><p>Explain the problems that would arise without a standard calling
convention.</p></li>
</ul>
</section>
<section id="going-further">
<h3>Going Further<a class="headerlink" href="#going-further" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>Do you think it’s better for a system to have a large set of
primitives or a small one, assuming that the larger set can be
written in terms of the smaller one?</p></li>
<li><p>The factorial function can be written non-recursively. Do so.</p></li>
<li><p>Find an application on the computer you use regularly. Try to locate
a specific feature, and practice breaking that feature out into
functions. Define the function interfaces between that feature and
the rest of the program.</p></li>
<li><p>Come up with your own calling convention. Rewrite the programs in
this chapter using it. An example of a different calling convention
would be to pass parameters in registers rather than the stack, to
pass them in a different order, to return values in other registers
or memory locations. Whatever you pick, be consistent and apply it
throughout the whole program.</p></li>
<li><p>Can you build a calling convention without using the stack? What
limitations might it have?</p></li>
<li><p>What test cases should we use in our example program to check to see
if it is working properly?</p></li>
</ul>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id7" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>Function parameters can also be used to hold pointers to data that
the function wants to send back to the program.</p>
</aside>
<aside class="footnote brackets" id="id8" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p>This is generally considered bad practice. Imagine if a program is
written this way, and in the next version they decided to allow a
single instance of the program edit multiple files. Each function
would then have to be modified so that the file that was being
manipulated would be passed as a parameter. If you had simply passed
it as a parameter to begin with, most of your functions could have
survived your upgrade unchanged.</p>
</aside>
<aside class="footnote brackets" id="id9" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">3</a><span class="fn-bracket">]</span></span>
<p>A <em>convention</em> is a way of doing things that is standardized, but not
forcibly so. For example, it is a convention for people to shake
hands when they meet. If I refuse to shake hands with you, you may
think I don’t like you. Following conventions is important because it
makes it easier for others to understand what you are doing, and
makes it easier for programs written by multiple independent authors
to work together.</p>
</aside>
<aside class="footnote brackets" id="id10" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">4</a><span class="fn-bracket">]</span></span>
<p>Just a reminder - the dollar sign in front of the eight indicates
immediate mode addressing, meaning that we subtract the number 8
itself from %esp; rather than the value at address 8.</p>
</aside>
<aside class="footnote brackets" id="id11" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">5</a><span class="fn-bracket">]</span></span>
<p>This is not always strictly needed unless you are saving registers on
the stack before a function call. The base pointer keeps the stack
frame in a reasonably consistent state. However, it is still a good
idea, and is absolutely necessary if you are temporarily saving
registers on the stack..</p>
</aside>
<aside class="footnote brackets" id="id12" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">6</a><span class="fn-bracket">]</span></span>
<p>By “running at the same time” I am talking about the fact that one
will not have finished before a new one is activated. I am not
implying that their instructions are running at the same time.</p>
</aside>
</aside>
</section>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="files.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Dealing with Files</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="firstprog.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Your First Programs</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2025, Jonathan Bartlett
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">All About Functions</a><ul>
<li><a class="reference internal" href="#dealing-with-complexity">Dealing with Complexity</a></li>
<li><a class="reference internal" href="#how-functions-work">How Functions Work</a></li>
<li><a class="reference internal" href="#assembly-language-functions-using-the-c-calling-convention">Assembly-Language Functions using the C Calling Convention</a></li>
<li><a class="reference internal" href="#a-function-example">A Function Example</a></li>
<li><a class="reference internal" href="#recursive-functions">Recursive Functions</a></li>
<li><a class="reference internal" href="#review">Review</a><ul>
<li><a class="reference internal" href="#know-the-concepts">Know the Concepts</a></li>
<li><a class="reference internal" href="#use-the-concepts">Use the Concepts</a></li>
<li><a class="reference internal" href="#going-further">Going Further</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="static/documentation_options.js?v=d45e8c67"></script>
    <script src="static/doctools.js?v=9bcbadda"></script>
    <script src="static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="static/scripts/furo.js?v=46bd48cc"></script>
    </body>
</html>