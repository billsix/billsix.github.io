Add Translate Method to Vertex - Demo 05
========================================


Purpose
^^^^^^^
Restructure the code towards the model view projection
pipeline.

Transforming vertices, such as translating, is the core concept
of computer graphics.


.. figure:: static/screenshots/demo05.png
    :align: center
    :alt: Demo 05
    :figclass: align-center

    Demo 05

How to Execute
^^^^^^^^^^^^^^

On Linux or on MacOS, in a command prompt, type "python src/demo05/demo.py".
On Windows, in a command prompt, type "python src\\demo05\\demo.py".


Move the Paddles using the Keyboard
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

==============  ======================
Keyboard Input  Action
==============  ======================
*w*             Move Left Paddle Up
*s*             Move Left Paddle Down
*k*             Move Right Paddle Down
*i*             Move Right Paddle Up
==============  ======================


Translation
^^^^^^^^^^^

Dealing with the two Paddles the way we did before is not
ideal.  Both Paddles have the same size, although they are placed
in different spots of the screen.  We should be able to
a set of vertices for the Paddle, relative to the paddle's center,
that is independent of its
placement in NDC.

Rather than using values for each vertex relative to NDC, in the
Paddle data structure, each vertex will be an offset from
the center of the Paddle.  The center of the paddle will be considered x=0, y=0.
Before rendering, each Paddle's
vertices will need to be translated to its center relative to NDC.

.. figure:: static/demo05.png
    :align: center
    :alt:
    :figclass: align-center

    Paddle space



All methods on verticies will be returning new verticies,
rather than mutating the instance variables.  The author
does this on purpose to enable method-chaining the Python
methods, which will be useful later on.


.. math::

    \begin{equation*}
     \vec{T}(\vec{v};\vec{t}) =
    \begin{bmatrix}
    v_{x} \\
    v_{y}
    \end{bmatrix} +
    \begin{bmatrix}
    t_{x} \\
    t_{y}
    \end{bmatrix}
    \end{equation*}

Code
^^^^

Data Structures
~~~~~~~~~~~~~~~

.. literalinclude:: ../src/demo05/demo.py
   :language: python
   :linenos:
   :lineno-start: 88
   :lines: 88-94

We added a translate method to the Vertex class.  Given a translation amount, the vertex
will be shifted by that amount.  This is a primitive that we will be using to transform
from one space to another.

.. literalinclude:: ../src/demo05/demo.py
   :language: python
   :linenos:
   :lineno-start: 97
   :lines: 97-103

Add a position instance variable to the Paddle class.  This position is the center of
the paddle, defined relative to NDC.  The vertices of the paddle will be defined
relative to the center of the paddle.

Instantiation of the Paddles
~~~~~~~~~~~~~~~~~~~~~~~~~~~~


.. literalinclude:: ../src/demo05/demo.py
   :language: python
   :linenos:
   :lineno-start: 106
   :lines: 106-130

* The verticies are now defined as relative distances from the center of the paddle.  The centers
  of each paddle are placed in positions relative to NDC that preserve the positions of the
  paddles, as they were in the previous demo.

Handling User Input
~~~~~~~~~~~~~~~~~~~

.. literalinclude:: ../src/demo05/demo.py
   :language: python
   :linenos:
   :lineno-start: 133
   :lines: 133-143

* New!  We put the transformation on the center of the paddle, instead
  of directly on each vertex

The Event Loop
~~~~~~~~~~~~~~



.. literalinclude:: ../src/demo05/demo.py
   :language: python
   :linenos:
   :lineno-start: 150
   :lines: 150-166

.. literalinclude:: ../src/demo05/demo.py
   :language: python
   :linenos:
   :lineno-start: 168
   :lines: 168-182


.. figure:: static/demo05.png
    :align: center
    :alt:
    :figclass: align-center

    Paddle space

Since previous demos covered transformations from NDC to viewport, and since
OpenGL does the conversions from viewport to window, we can ignore those
parts of this Cayley graph.

The only part of the diagram that we need to think about is the function
that converts from paddle1's space to NDC, and from paddle2's space to NDC.

These functions in the Python code are the translation of the paddle's center (i.e. paddle1.position)
by the vertex's offset from the center.

N.B.  In the code, I name the vertices by their space.  I.e. "modelSpace" instead of "vertex_relative_to_modelspace".
I do this to emphasize that you should view the transformation as happening to the "graph paper", instead of to each
of the points.  This will be explained more clearly later.
