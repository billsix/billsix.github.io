Rotation Fixed - Sequence of Transformations - Demo 09
======================================================

Purpose
^^^^^^^

Make the rotations work correctly by thinking about the problem
more clearly.

We do this by the following:

* Read sequence of transformations in the reverse order, from bottom to top.


.. figure:: static/screenshots/demo09.png
    :align: center
    :alt: Demo 09
    :figclass: align-center

    Demo 09

How to Execute
^^^^^^^^^^^^^^

On Linux or on MacOS, in a command prompt, type "python src/demo09/demo.py".
On Windows, in a command prompt, type "python src\\demo09\\demo.py".


Move the Paddles using the Keyboard
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

==============  ================================
Keyboard Input  Action
==============  ================================
*w*             Move Left Paddle Up
*s*             Move Left Paddle Down
*k*             Move Right Paddle Down
*i*             Move Right Paddle Up

*d*             Increase Left Paddle's Rotation
*a*             Decrease Left Paddle's Rotation
*l*             Increase Right Paddle's Rotation
*j*             Decrease Right Paddle's Rotation
==============  ================================

Description
^^^^^^^^^^^

In the previous demo, the initial translate is effectively canceled out,
leaving just a rotation and then a translation.


.. math::
    \begin{equation}
    \begin{split}
    \vec{f}_{p}^{w}  & = \vec{t} \circ \vec{r} \circ {\vec{t}}^{-1} \circ \vec{t} \\
                     & = \vec{t} \circ \vec{r}
    \end{split}
    \end{equation}

Where t and r are the translate and rotate functions for a paddle.

    
So we really just need to apply the rotation first, and then the translation.

To understand why the code in this demo works, you can think
about it in one of two ways, forwards or backwards.

Reading transformations top-down
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When reading a composition of function calls top down,
all the transformations happen relative to the global
origin and axises, i.e. the natural *basis*.  After each function call, the basis
is set back to the origin basis.

.. literalinclude:: ../src/demo09/demo.py
   :language: python
   :linenos:
   :lineno-start: 195
   :lines: 195-196


.. figure:: static/rotate1-forwards.gif
    :align: center
    :alt: Rotation Forwards
    :figclass: align-center

    Rotation Forwards


Reading transformations bottom-up
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Alternatively, you can read the transformations backwards,
where the operations
all cumulatively modify the current axises and origin, i.e. basis, to a new basis.
All subsequent functions move that relative basis to a new relative basis.


.. literalinclude:: ../src/demo09/demo.py
   :language: python
   :linenos:
   :lineno-start: 195
   :lines: 195-196

.. figure:: static/rotate1-backwards.gif
    :align: center
    :alt: Rotation Bacwards
    :figclass: align-center

    Rotation Backwards

Suggested Order
~~~~~~~~~~~~~~~

The author has a strong opinion on the matter for computer graphics.

Start at world space node.  As a reminder, this is the toplevel coordinate
system that we choose to use.  It's whatever you want it to be.

.. figure:: static/demo06.png
    :align: center
    :alt: Demo 06
    :figclass: align-center

    Demo 06

Think of world space's origin, x and y axises.  On the Cayley graph, move towards each modelspace node,
which is against the direction of the edge,  Look at that edge's correponding
sequence of function calls in the graphics code.  Read the transformations
from the bottom up, imagining a transformed local coordinate system against which
each function in the sequence operates.

The data you plot that is in its own modelspace will actually be plotted relative to that transformed coordinate
system.


For the linear-algebra inclined reader, we've used

.. math::
    \begin{equation}
    L * (M * \vec{x})     = (L * M) * \vec{x}
     \end{equation}

to understand a complex system of equations, sometimes looking at the left
side of the equations, sometimes looking at the right side.
     


.. literalinclude:: ../src/demo09/demo.py
   :language: python
   :linenos:
   :lineno-start: 195
   :lines: 195-196


Now go back to world space.  Think
of all modelspace data as having already been "plotted".  So now follow
the edges to screen space,
reading the transformations
from top down, and resetting the coordinate system after every transformation.

.. literalinclude:: ../src/demo09/demo.py
   :language: python
   :linenos:
   :lineno-start: 197
   :lines: 197





As a side note,	the computer has no notion of coordinate systems.  It just has a sequence of procedures
to apply on a sequence of numbers.  For us humans to make sense of what we are modeling,
and to implement it correctly, we need to be able to reason and compose our thoughts clearly.

    
Code
^^^^


The Event Loop
~~~~~~~~~~~~~~



.. literalinclude:: ../src/demo09/demo.py
   :language: python
   :linenos:
   :lineno-start: 172
   :lines: 172

::

    ...

.. literalinclude:: ../src/demo09/demo.py
   :language: python
   :linenos:
   :lineno-start: 191
   :lines: 191-199

* Read line 196
* Read line 195
* Reset the coordinate system
* Read line 197
	   
::

    ...

.. literalinclude:: ../src/demo09/demo.py
   :language: python
   :linenos:
   :lineno-start: 204
   :lines: 204-210

* Read line 206
* Read line 207
* Reset the coordinate system
* Read line 208

	   

ALSO, see mvpVisualization/demo2.py.  This is an animation of the code, albeit in 3D space.

	   
