Rotation Fixed - Sequence of Transformations - Demo 09
======================================================

Purpose
^^^^^^^

Make the rotations work correctly by thinking about the problem
more clearly.

We do this by the following:

* Read a sequence of transformations from bottom to top,
  where each transformation of the graph paper is relative
  to the current coordinate system.


.. figure:: static/screenshots/demo09.png
    :align: center
    :alt: Demo 09
    :figclass: align-center

    Demo 09

How to Execute
^^^^^^^^^^^^^^

On Linux or on MacOS, in a command prompt, type "python src/demo09/demo.py".
On Windows, in a command prompt, type "python src\\demo09\\demo.py".


Move the Paddles using the Keyboard
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

==============  ================================
Keyboard Input  Action
==============  ================================
*w*             Move Left Paddle Up
*s*             Move Left Paddle Down
*k*             Move Right Paddle Down
*i*             Move Right Paddle Up

*d*             Increase Left Paddle's Rotation
*a*             Decrease Left Paddle's Rotation
*l*             Increase Right Paddle's Rotation
*j*             Decrease Right Paddle's Rotation
==============  ================================

Description
^^^^^^^^^^^

In the previous demo, The initial translate is effectively canceled out,
leaving a rotation and then a translation.
Translate inverse(Translate) Rotate Translate

So we really just need to do a rotation first, and then a translation.
But this can be counterintuitive at first because we like to think
in relative terms.

To understand why the code in this demo works, you can think
about it in one of two ways, forwards or backwards.

Reading transformations top-down
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When reading a composition of function calls top down,
all the transformations happen relative to the global
origin and axises, i.e. the natural *basis*.  After each function call, the basis
is set back to the origin basis.

.. literalinclude:: ../src/demo09/demo.py
   :language: python
   :linenos:
   :lineno-start: 195
   :lines: 195-196


.. figure:: static/rotate1-forwards.gif
    :align: center
    :alt: Rotation Forwards
    :figclass: align-center

    Rotation Forwards


Reading transformations bottom-up
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


or, you can read the transformations backwards,
where the operations
all modify the current axises and origin, i.e. basis, to a new basis.
All subsequent functions move that relative basis to a new relative basis.


.. literalinclude:: ../src/demo09/demo.py
   :language: python
   :linenos:
   :lineno-start: 195
   :lines: 195-196

.. figure:: static/rotate1-backwards.gif
    :align: center
    :alt: Rotation Bacwards
    :figclass: align-center

    Rotation Backwards

Suggested Order
~~~~~~~~~~~~~~~

The author has a strong opinion on the matter for computer graphics.

Start at world space.

.. figure:: static/demo06.png
    :align: center
    :alt: Demo 06
    :figclass: align-center

    Demo 06

Think of the origin, x and y axises.  Move towards each modelspace,
imagining a transformed local coordinate system, and read the transformations
backwards.  The data you plot will be relative to that transformed coordinate
system.

.. literalinclude:: ../src/demo09/demo.py
   :language: python
   :linenos:
   :lineno-start: 195
   :lines: 195-196


Now go back to world space.  It's the origin coordinate system, and think
of everything of having already been "plotted".
For every transformations towards screen space, read the transformations
from top down, resetting the coordinate system after every transformation.

.. literalinclude:: ../src/demo09/demo.py
   :language: python
   :linenos:
   :lineno-start: 197
   :lines: 197






I prefer to think graphically instead of symbolically.
Another way you can think of this is to rotate the the x axis
and y axis, create graph paper (tick marks) along those new
axis, and then draw the geometry on that new "basis",
instead of the natural basis. (Natural basis just means
the normal x and y axis).
Think of basis as an origin, a unit in various directions,
a graph paper lines drawn.  Then your geometry is drawn
in that space.

In revisting demo 6's space, if we read all of the transformations
below in order, it's following the order of function application.

If instead we read the transformation between spaces backwards in code,
(and going the opposite direction of the arrows), we can view a coordinate
system that is changing (origin can move, and axises can rotate/scale)



ALSO, see mvpVisualization/demo.py and mvpVisualization/demoAnimation.py.
THESE WILL SHOW THE TRANSMORTAIONS backwards much more intuitively.


Same thing for the second paddle.

.. figure:: static/rotate2-forwards.gif
    :align: center
    :alt: Rotate Paddle 2 Forwards
    :figclass: align-center

    Rotate Paddle 2 Forwards

.. figure:: static/rotate2-backwards.gif
    :align: center
    :alt: Rotate Paddle 2 Backwards
    :figclass: align-center

    Rotate Paddle 2 Backwards


Code
^^^^


The Event Loop
~~~~~~~~~~~~~~



.. literalinclude:: ../src/demo09/demo.py
   :language: python
   :linenos:
   :lineno-start: 172
   :lines: 172

::

    ...

.. literalinclude:: ../src/demo09/demo.py
   :language: python
   :linenos:
   :lineno-start: 191
   :lines: 191-199

::

    ...

.. literalinclude:: ../src/demo09/demo.py
   :language: python
   :linenos:
   :lineno-start: 204
   :lines: 204-210
